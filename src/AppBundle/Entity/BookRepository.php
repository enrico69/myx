<?php

namespace AppBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\NoResultException;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * BookRepository
 *
 * This is the repository for the "Book" entities.
 * 
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 * 
 * @author Eric COURTIAL
 */
class BookRepository extends EntityRepository {
    
    /**
     * 
     * Extract the last five registered books.
     * 
     * @return an array of Book entities or throws an exception.
     * @author Eric COURTIAL
     */
    public function findLast($intQty) {
        
        $strQuery = $this->createQueryBuilder('p')
            ->orderBy('p.id', 'DESC')
            ->setMaxResults($intQty)
            ->getQuery();
        
        try {
            $arrQueryResults = $strQuery->getResult();
        } catch (Exception $exception) {
            throw $exception;
        }

        // The SQL request must return at least one result
        if(count($arrQueryResults) == 0) {
            throw new NoResultException;
        }

        return $arrQueryResults;
    }
    
    /**
     * Count all the books registered in the Database
     * @return integer : the quantity of registered books.
     * @throws \ErrorException
     * @author Eric COURTIAL
     */
    public function countAllBooks() {
        
        try {
            $allBooks = $this->findAll();
        } catch (Exception $exception){
            // ici gestion de l'erreur dans le log
            throw $exception;
        }
        
        return count($allBooks);
    }
    
    /**
     * 
     * Execute a research by occurence in the title OR the keywords
     * OR the description of the book.
     * 
     * @param string $strRequest is the searched keyword
     * @param int $intPage is the number of the page of results
     * @return paginator (array of books)
     * @throws \AppBundle\Entity\Exception
     * @throws NoResultException
     * @author Eric COURTIAL
     */
    public function findWhereContains($strType, $strRequest, $intPage) {
        
        if($intPage > 1) {
            $intStart = (($intPage - 1) * Book::QTY_BOOKS);
            $intEnd = $intStart + Book::QTY_BOOKS - 1;
        } else {
            $intStart = 0;
            $intEnd = Book::QTY_BOOKS - 1;
        }
        
        $strField = Book::$arrSearchTypes[$strType];
        
        $strQuery = $this->createQueryBuilder('p')
            ->Where('p.' . $strField . ' LIKE :Request')
            ->setFirstResult($intStart)
            ->setMaxResults(Book::QTY_BOOKS)
            ->setParameter('Request', "%$strRequest%");
        
        try {
            $arrQueryResults = new Paginator($strQuery);
        } catch (Exception $exception) {
            throw $exception;
        }
        
        // The SQL request must return at least one result
        if(count($arrQueryResults) == 0) {
            throw new NoResultException;
        }

        return $arrQueryResults;
    }
    
    /**
     * 
     * Extract all the books from an editor
     * 
     * @param int $intEditorId is the id of the editor
     * @param int $intPage is the number of the page of results
     * @return paginator (array of books)
     * @throws \AppBundle\Entity\Exception
     * @throws NoResultException
     * @author Eric COURTIAL
     */
    public function findByEditor($intEditorId, $intPage) {
        
        if($intPage > 1) {
            $intStart = (($intPage - 1) * Book::QTY_BOOKS);
            $intEnd = $intStart + Book::QTY_BOOKS - 1;
        } else {
            $intStart = 0;
            $intEnd = Book::QTY_BOOKS - 1;
        }
        
        $strQuery = $this->createQueryBuilder('p')
            ->Where('p.editor = :Request')
            ->setFirstResult($intStart)
            ->setMaxResults(Book::QTY_BOOKS)
            ->setParameter('Request', $intEditorId);
        
        try {
            $arrQueryResults = new Paginator($strQuery);
        } catch (Exception $exception) {
            throw $exception;
        }
        
        // The SQL request must return at least one result
        if(count($arrQueryResults) == 0) {
            throw new NoResultException;
        }

        return $arrQueryResults;
    }
    
    /**
     * 
     * Extract all the books from a format
     * 
     * @param int $intFormatId is the id of the format
     * @param int $intPage is the number of the page of results
     * @return paginator (array of books)
     * @throws \AppBundle\Entity\Exception
     * @throws NoResultException
     * @author Eric COURTIAL
     */
    public function findByFormat($intFormatId, $intPage) {
        
        if($intPage > 1) {
            $intStart = (($intPage - 1) * Book::QTY_BOOKS);
            $intEnd = $intStart + Book::QTY_BOOKS - 1;
        } else {
            $intStart = 0;
            $intEnd = Book::QTY_BOOKS - 1;
        }
        
        $strQuery = $this->createQueryBuilder('p')
            ->Where('p.format = :Request')
            ->setFirstResult($intStart)
            ->setMaxResults(Book::QTY_BOOKS)
            ->setParameter('Request', $intFormatId);
        
        try {
            $arrQueryResults = new Paginator($strQuery);
        } catch (Exception $exception) {
            throw $exception;
        }
        
        // The SQL request must return at least one result
        if(count($arrQueryResults) == 0) {
            throw new NoResultException;
        }

        return $arrQueryResults;
    }
    
    /**
     * 
     * Extract all the books from a language
     * 
     * @param int $intLanguageId is the id of the language
     * @param int $intPage is the number of the page of results
     * @return paginator (array of books)
     * @throws \AppBundle\Entity\Exception
     * @throws NoResultException
     * @author Eric COURTIAL
     */
    public function findByLanguage($intLanguageId, $intPage) {
        
        if($intPage > 1) {
            $intStart = (($intPage - 1) * Book::QTY_BOOKS);
            $intEnd = $intStart + Book::QTY_BOOKS - 1;
        } else {
            $intStart = 0;
            $intEnd = Book::QTY_BOOKS - 1;
        }
        
        $strQuery = $this->createQueryBuilder('p')
            ->Where('p.language = :Request')
            ->setFirstResult($intStart)
            ->setMaxResults(Book::QTY_BOOKS)
            ->setParameter('Request', $intLanguageId);
        
        try {
            $arrQueryResults = new Paginator($strQuery);
        } catch (Exception $exception) {
            throw $exception;
        }
        
        // The SQL request must return at least one result
        if(count($arrQueryResults) == 0) {
            throw new NoResultException;
        }

        return $arrQueryResults;
    }
    
    /**
     * 
     * Return all the books sorted by title.
     * 
     * @param int $intPage is the number of the page of results
     * @return mixed array of Book entity. 
     * @throws \ErrorException
     * @throws NoResultException
     * 
     * @author Eric COURTIAL
     *
     */
    public function findAllOrderedByTitle($intPage = 1) {
        
        $intRefValue = Book::QTY_BOOKS;
        
        if($intPage > 1) {
            $intStart = (($intPage - 1) * $intRefValue);
            $intEnd = $intStart + $intRefValue - 1;
        } else {
            $intStart = 0;
            $intEnd = $intRefValue - 1;
        }
        
        $strQuery = $this->createQueryBuilder('p')
            ->setFirstResult($intStart)
            ->setMaxResults($intRefValue)
            ->orderBy('p.title', 'ASC');
        
        try {
            $arrQueryResults = new Paginator($strQuery);
        } catch (Exception $exception) {
            throw $exception;
        }

        // The SQL request must return at least one result
        if(count($arrQueryResults) == 0) {
            throw new NoResultException;
        }

        return $arrQueryResults;
        
    }
    
}
